from math import pi, sqrt

class point_charge:
    """Class representing a point charge in the two-dimensional Cartesian plane"""
    set_of_all_charges = []
    const_permittivity = 8.85*10.0**(-12)
    const_Coulomb = 1 / (4*pi*const_permittivity)
    const_electronic_charge = 1.602*10.0**(-19)

    def __init__(self, charge=1.0, position_x=1.0, position_y=1.0):
        """Creates a new point charge object, given charge in Coulombs, and positions x and y in meters"""
        # Charge of the particle is given in Coulombs
        self.charge = charge

        # Set the sign of the charge
        if self.charge > 0.0:
            self.sign_charge = +1.0
        elif self.charge < 0.0:
            self.sign_charge = -1.0
        else:
            self.sign_charge = 0.0

        # Position of the point charge
        self.pos_x = position_x
        self.pos_y = position_y

        # Add the point charge to the set of all point charges
        point_charge.set_of_all_charges.append(self)

    def contribution_EField(self, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the electric field vector E (in units of Coulombs/meter) generated by the point charge at the given position (test_pos_x, test_pos_y) in meters"""

        if self.sign_charge == "0":
            return 0

        # Compute the following quantities related to the difference in position between the test point and point charge
        disp_xdiff = test_pos_x-self.pos_x
        disp_ydiff = test_pos_y-self.pos_y
        disp_magnitude2 = disp_xdiff**2 + disp_ydiff**2
        disp_magnitude = sqrt(disp_magnitude2)

        # Apply Coulumb's law to compute for the magnitude of said contribution
        EF_vector_magnitude = point_charge.const_Coulomb*abs(self.charge)/disp_magnitude2

        # Get the vector components of the electric field contribution via similar triangles formula and sign of charge
        EF_vector_x = self.sign_charge*EF_vector_magnitude*disp_xdiff/disp_magnitude
        EF_vector_y = self.sign_charge*EF_vector_magnitude*disp_ydiff/disp_magnitude
        return EF_vector_x, EF_vector_y

    def contribution_EPotential(self, test_pos_x=0.0, test_pos_y=0.0):
        """Returns the electric potential (in Volts) at a point (test_pos_x, test_pos_y) associated with the electric field generated by a selected point charge. Potential is assumed to be zero at infinite distances."""
        # Compute the following quantities related to the difference in position between the test point and point charge
        disp_xdiff = test_pos_x - self.pos_x
        disp_ydiff = test_pos_y - self.pos_y
        disp_magnitude = sqrt(disp_xdiff ** 2 + disp_ydiff ** 2)

        # Apply Coulumb's law to compute for the magnitude of said contribution
        EPotential = point_charge.const_Coulomb * self.charge/ disp_magnitude
        return EPotential

    @classmethod
    def total_EField(cls, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the electric field vector E (in units of Coulombs/meter) generated by all existing point charges at the given position (test_pos_x, test_pos_y) in meters """
        total_EF_vector_x = 0
        total_EF_vector_y = 0
        for pt_charge in cls.set_of_all_charges:
            change_x, change_y = pt_charge.contribution_EField(test_pos_x, test_pos_y)
            total_EF_vector_x += change_x
            total_EF_vector_y += change_y
        return total_EF_vector_x, total_EF_vector_y

    @classmethod
    def net_electrostatic_force(cls, test_charge=1.0, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the net electrostatic force Fnet (in Newtons) experienced by a test charge (in Coulombs) at position (test_pos_x, test_pos_y) in meters. This function considers the electric field generated by all existing point charges."""
        EF_vector_x, EF_vector_y = cls.total_EField(test_pos_x, test_pos_y)
        force_vector_x, force_vector_y = test_charge*EF_vector_x, test_charge*EF_vector_y
        return force_vector_x, force_vector_y

    def net_electrostatic_force_2(self):
        """Calculates the x and y components of the net electrostatic force Fnet (in Newtons) experienced by a declared point charge object. This function considers the electric field generated by all other point charges."""
        # List of all charges that are not the selected point charge
        set_of_other_charges = [charge for charge in point_charge.set_of_all_charges if charge is not self]
        total_EF_vector_x = 0
        total_EF_vector_y = 0
        for pt_charge in set_of_other_charges:
            change_x, change_y = pt_charge.contribution_EField(self.pos_x, self.pos_y)
            total_EF_vector_x += change_x
            total_EF_vector_y += change_y
        force_vector_x, force_vector_y = self.charge*total_EF_vector_x, self.charge*total_EF_vector_y
        return force_vector_x, force_vector_y

    @classmethod
    def total_EPotential(cls, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the electric potential (in Volts) at the point (test_pos_x, test_pos_y) associated with the total electric field generated by all point charges. Potential is assumed to be zero at infinite distances."""
        total_value_EPotential = 0
        for pt_charge in cls.set_of_all_charges:
            total_value_EPotential += pt_charge.contribution_EPotential(test_pos_x, test_pos_y)
        return total_value_EPotential

    def total_EPotential2(self):
        """Calculates the electric potential (in Volts) at the position of the selected point charge, associated with the electric field of all other existing point charges. Potential is assumed to be zero at infinite distances."""
        # List of all charges that are not the selected point charge
        set_of_other_charges = [charge for charge in point_charge.set_of_all_charges if charge is not self]
        total_value_EPotential = 0
        for pt_charge in set_of_other_charges:
            total_value_EPotential += pt_charge.contribution_EPotential(self.pos_x, self.pos_y)
        return total_value_EPotential

    @classmethod
    def clear(cls):
        """Removes all existing point charges"""
        cls.set_of_all_charges = []