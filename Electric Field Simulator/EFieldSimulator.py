
"""This program predicts and simulates the electric field lines and equipotential lines generated by one \n
 or more specified point charges on the Cartesian coordinate plane via Coulomb's Law. Functions and classes \n
 are provided for generating groups of charges that approximate charged rods, bars, rings, and circles, and
 for displaying said electric field and equipotential lines."""
# Created by Francis Miguel J. Sanguyo on June 10-11, 2024


# Import necessary packages
from math import pi, sqrt, cos, sin
from numpy import linspace, zeros, meshgrid, quantile, copy
from matplotlib.pyplot import subplots, show, subplots_adjust, figure

class point_charge:
    """Class representing a point charge in the two-dimensional Cartesian plane"""
    set_of_all_charges = []
    const_permittivity = 8.85*10.0**(-12)
    const_Coulomb = 1 / (4*pi*const_permittivity)
    const_electronic_charge = 1.602*10.0**(-19)

    def __init__(self, charge=1.0, position_x=1.0, position_y=1.0):
        """Creates a new point charge object, given charge in Coulombs, and positions x and y in meters"""
        # Charge of the particle is given in Coulombs
        self.charge = charge

        # Set the sign of the charge
        if self.charge > 0.0:
            self.sign_charge = +1.0
        elif self.charge < 0.0:
            self.sign_charge = -1.0
        else:
            self.sign_charge = 0.0

        # Position of the point charge
        self.pos_x = position_x
        self.pos_y = position_y

        # Add the point charge to the set of all point charges
        point_charge.set_of_all_charges.append(self)

    def contribution_EField(self, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the electric field vector E (in units of Coulombs/meter) generated by the point charge at the given position (test_pos_x, test_pos_y) in meters"""

        if self.sign_charge == "0":
            return 0

        # Compute the following quantities related to the difference in position between the test point and point charge
        disp_xdiff = test_pos_x-self.pos_x
        disp_ydiff = test_pos_y-self.pos_y
        disp_magnitude2 = disp_xdiff**2 + disp_ydiff**2
        disp_magnitude = sqrt(disp_magnitude2)

        # Apply Coulumb's law to compute for the magnitude of said contribution
        EF_vector_magnitude = point_charge.const_Coulomb*abs(self.charge)/disp_magnitude2

        # Get the vector components of the electric field contribution via similar triangles formula and sign of charge
        EF_vector_x = self.sign_charge*EF_vector_magnitude*disp_xdiff/disp_magnitude
        EF_vector_y = self.sign_charge*EF_vector_magnitude*disp_ydiff/disp_magnitude
        return EF_vector_x, EF_vector_y

    def contribution_EPotential(self, test_pos_x=0.0, test_pos_y=0.0):
        """Returns the electric potential (in Volts) at a point (test_pos_x, test_pos_y) associated with the electric field generated by a selected point charge. Potential is assumed to be zero at infinite distances."""
        # Compute the following quantities related to the difference in position between the test point and point charge
        disp_xdiff = test_pos_x - self.pos_x
        disp_ydiff = test_pos_y - self.pos_y
        disp_magnitude = sqrt(disp_xdiff ** 2 + disp_ydiff ** 2)

        # Apply Coulumb's law to compute for the magnitude of said contribution
        EPotential = point_charge.const_Coulomb * self.charge/ disp_magnitude
        return EPotential

    @classmethod
    def total_EField(cls, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the electric field vector E (in units of Coulombs/meter) generated by all existing point charges at the given position (test_pos_x, test_pos_y) in meters """
        total_EF_vector_x = 0
        total_EF_vector_y = 0
        for pt_charge in cls.set_of_all_charges:
            change_x, change_y = pt_charge.contribution_EField(test_pos_x, test_pos_y)
            total_EF_vector_x += change_x
            total_EF_vector_y += change_y
        return total_EF_vector_x, total_EF_vector_y

    @classmethod
    def net_electrostatic_force(cls, test_charge=1.0, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the x and y components of the net electrostatic force Fnet (in Newtons) experienced by a test charge (in Coulombs) at position (test_pos_x, test_pos_y) in meters. This function considers the electric field generated by all existing point charges."""
        EF_vector_x, EF_vector_y = cls.total_EField(test_pos_x, test_pos_y)
        force_vector_x, force_vector_y = test_charge*EF_vector_x, test_charge*EF_vector_y
        return force_vector_x, force_vector_y

    def net_electrostatic_force_2(self):
        """Calculates the x and y components of the net electrostatic force Fnet (in Newtons) experienced by a declared point charge object. This function considers the electric field generated by all other point charges."""
        # List of all charges that are not the selected point charge
        set_of_other_charges = [charge for charge in point_charge.set_of_all_charges if charge is not self]
        total_EF_vector_x = 0
        total_EF_vector_y = 0
        for pt_charge in set_of_other_charges:
            change_x, change_y = pt_charge.contribution_EField(self.pos_x, self.pos_y)
            total_EF_vector_x += change_x
            total_EF_vector_y += change_y
        force_vector_x, force_vector_y = self.charge*total_EF_vector_x, self.charge*total_EF_vector_y
        return force_vector_x, force_vector_y

    @classmethod
    def total_EPotential(cls, test_pos_x=0.0, test_pos_y=0.0):
        """Calculates the electric potential (in Volts) at the point (test_pos_x, test_pos_y) associated with the total electric field generated by all point charges. Potential is assumed to be zero at infinite distances."""
        total_value_EPotential = 0
        for pt_charge in cls.set_of_all_charges:
            total_value_EPotential += pt_charge.contribution_EPotential(test_pos_x, test_pos_y)
        return total_value_EPotential

    def total_EPotential2(self):
        """Calculates the electric potential (in Volts) at the position of the selected point charge, associated with the electric field of all other existing point charges. Potential is assumed to be zero at infinite distances."""
        # List of all charges that are not the selected point charge
        set_of_other_charges = [charge for charge in point_charge.set_of_all_charges if charge is not self]
        total_value_EPotential = 0
        for pt_charge in set_of_other_charges:
            total_value_EPotential += pt_charge.contribution_EPotential(self.pos_x, self.pos_y)
        return total_value_EPotential

    @classmethod
    def clear(cls):
        """Removes all existing point charges"""
        cls.set_of_all_charges = []


# Additional Functions:
def chargedRod(charge=1.0, start_x=0.0, start_y=0.0, end_x=1.0, end_y=1.0, number_of_points=20):
    """Creates a set of point charges placed along a line"""
    pos_xrange = list(linspace(start_x, end_x, number_of_points))
    pos_yrange = list(linspace(start_y, end_y, number_of_points))
    pos_points = [(x, y) for x, y in zip(pos_xrange, pos_yrange)]
    charge_per_point = charge / number_of_points
    point_charges = []
    for point in pos_points:
        new_charge = point_charge(charge_per_point, point[0], point[1])
        point_charges.append(new_charge)
    return point_charges

def chargedBar(charge=1.0, start_x=0.0, start_y=0.0, end_x=1.0, end_y=1.0, number_of_column_points=20, number_of_row_points=1, aspect_ratio=10.0):
    """Creates an array of point charges (number_of_column_points x number_of_row_points) placed in a bar with a specified aspect ratio"""

    if number_of_row_points == 1:
        point_charges = chargedRod(charge, start_x, start_y, end_x, end_y, number_of_column_points)
        return point_charges

    # Compute the following quantities related to the difference in position between the start and end points
    disp_xdiff = end_x - start_x
    disp_ydiff = end_y - start_y
    bar_length = sqrt(disp_xdiff ** 2 + disp_ydiff ** 2)
    bar_width = bar_length / aspect_ratio

    # Translate the start and end points to get the edges of the bar
    translation_width = bar_width/2
    translation_xdiff = translation_width * disp_ydiff/bar_length
    translation_ydiff = translation_width * (-disp_xdiff)/bar_length

    # Get the starting and ending x and y values for each row of the bar
    start_xvalues = list(linspace(start_x - translation_xdiff, start_x + translation_xdiff, number_of_row_points))
    start_yvalues = list(linspace(start_y - translation_ydiff, start_y + translation_ydiff, number_of_row_points))
    end_xvalues = list(linspace(end_x - translation_xdiff, end_x + translation_xdiff, number_of_row_points))
    end_yvalues = list(linspace(end_y - translation_ydiff, end_y + translation_ydiff, number_of_row_points))

    point_charges = []
    # Generate the point charges along each row by invoking the charged rod function
    charge_per_row = charge / number_of_row_points
    for i in range(number_of_row_points):
        point_charges = point_charges + chargedRod(charge_per_row, start_xvalues[i], start_yvalues[i], end_xvalues[i], end_yvalues[i], number_of_column_points)
    return point_charges

def chargedRing(charge=1.0, center_x=0.0, center_y=0.0, ring_diameter=1.0, number_of_points=10):
    """Creates an array of point charges distributed radially within a charged ring."""
    ring_radius = ring_diameter / 2
    angles = list(linspace(0, 2*pi, number_of_points+1))
    angles.pop()

    point_charges = []
    charge_per_point = charge / number_of_points
    for angle in angles:
        pos_x = center_x + ring_radius*cos(angle)
        pos_y = center_y + ring_radius*sin(angle)
        point_charges.append(point_charge(charge_per_point, pos_x, pos_y))
    return point_charges

def chargedDisk(charge=1.0, center_x=0.0, center_y=0.0, ring_diameter=1.0, tuple_number_of_points = (6, 10)):

    # Create the central point charge
    number_of_points = sum(tuple_number_of_points) + 1
    charge_per_point = charge / number_of_points
    point_charges = []
    point_charges.append(point_charge(charge_per_point, center_x, center_y))

    # Create rings of charge around the central point charge
    number_of_rings = len(tuple_number_of_points)
    ring_radii = list(linspace(0, ring_diameter/2, number_of_rings + 1))
    ring_radii.pop(0)
    for i in range(number_of_rings):
        ring_radius, ring_points = ring_radii[i], tuple_number_of_points[i]
        point_charges = point_charges + chargedRing(charge*ring_points/number_of_points, center_x, center_y, ring_radius*2, ring_points)
    return point_charges


class electric_field_display:
    set_of_all_charges = point_charge.set_of_all_charges  # these lists are equivalent to each other
    def __init__(self, bound_xmin = 0.0, bound_ymin = 0.0, bound_xmax = 1.0, bound_ymax = 1.0, resolution = 10, name = ""):
        """Creates a new instance of an electric field display, specified the boundary coordinates and number of points per unit meter"""
        self.bound_xmin = bound_xmin
        self.bound_ymin = bound_ymin
        self.bound_xmax = bound_xmax
        self.bound_ymax = bound_ymax
        self.resolution = resolution
        self.name = name
        self.size_m, self.size_n = int((bound_xmax - bound_xmin) * resolution), int((bound_ymax - bound_ymin) * resolution)
        self.EField_x = zeros((self.size_m, self.size_n))
        self.EField_y = zeros((self.size_m, self.size_n))
        self.EPotential = zeros((self.size_m, self.size_n))
        self.has_computed_EField_x = False
        self.has_computed_EField_y = False
        self.has_computed_EPotential = False
        self.AllPotentials = []

    def display_EFieldLines(self, EFieldDensity = 1.0):
        # Generate the grid of points to evaluate the electric field on the cartesian plane:
        x, y = linspace(self.bound_xmin, self.bound_xmax, self.size_n), linspace(self.bound_ymin, self.bound_ymax, self.size_m)
        x, y = meshgrid(x, y)

        if (not self.has_computed_EField_x) or (not self.has_computed_EField_y):
            for j in range(self.size_m):
                for i in range(self.size_n):
                    pos_x, pos_y = x[j][i], y[j][i]
                    EField_xcomponent, EField_ycomponent = point_charge.total_EField(pos_x, pos_y)
                    self.EField_x[j][i] = EField_xcomponent
                    self.EField_y[j][i] = EField_ycomponent
            self.has_computed_EField_x = True
            self.has_computed_EField_y = True

        # Plot the electric field lines, with (+) charges in red, and (-) charges in blue
        fig, ax = subplots(figsize=(9,5))
        if len(self.name) == 0:
            ax.set_title("Electric Field Lines")
        else:
            ax.set_title(f"Electric Field Lines of {self.name}")
        ax.set(xlabel="Horizontal position x (m)", ylabel="Vertical position x (m)")
        ax.grid(visible=True, which='major', axis='both')
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == +1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == +1.0], c='red', zorder=1)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == -1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == -1.0], c='blue', zorder=1)

        ax.streamplot(x, y, self.EField_x, self.EField_y, linewidth=1, density=EFieldDensity, zorder=0)
        show()
    def display_EPotential(self, max_number_of_potentials = 20, tuple_equipotentials=(), set_zero_potential = False, cutoff_threshold=10):
        # Generate the grid of points to evaluate the electric potential on the cartesian plane:
        x, y = linspace(self.bound_xmin, self.bound_xmax, self.size_n), linspace(self.bound_ymin, self.bound_ymax, self.size_m)
        x, y = meshgrid(x, y)

        if (not self.has_computed_EPotential):
            self.AllPotentials = []
            for j in range(self.size_m):
                for i in range(self.size_n):
                    pos_x, pos_y = x[j][i], y[j][i]
                    EPotential_value = point_charge.total_EPotential(pos_x, pos_y)
                    self.EPotential[j][i] = EPotential_value
                    self.AllPotentials.append(EPotential_value)
            self.has_computed_EPotential = True

        # Get the quantile values needed for the potentials
        number_of_quantiles = max_number_of_potentials # initial number of quantiles (excluding extrema)
        number_of_quantiles += 2  # accounts for the minimum and maximum values (which are excluded)

        # Sort all potential values
        self.AllPotentials.sort()

        # The top-most and bottom-most values will be removed
        # Get quantiles between cutoff_threshold% and (100 - cutoff_threshold)%
        lower_threshold = cutoff_threshold / 100
        upper_threshold = (100 - cutoff_threshold) / 100
        qValues = list(linspace(0, 1, number_of_quantiles))
        qValues = [q for q in qValues if ((q >= lower_threshold) and (q <= upper_threshold))]
        equipotential_levels = list(quantile(self.AllPotentials, qValues))

        # If the zero potential is to be set (True), let the lowest equipotential level be the zero potential.
        plotEPotential = copy(self.EPotential)
        if set_zero_potential:
            zero_potential = equipotential_levels[0]
            for j in range(self.size_m):
                for i in range(self.size_n):
                    plotEPotential[j][i] = plotEPotential[j][i] - zero_potential
            equipotential_levels = [potential - zero_potential for potential in equipotential_levels]

        # If specified, the equipotential levels can then be manually replaced:
        if len(tuple_equipotentials) != 0:
            equipotential_levels = list(tuple_equipotentials).copy()

        # Plot the equipotential lines
        fig, (ax, axbar) = subplots(ncols=2, gridspec_kw={'width_ratios': [13, 1]}, figsize=(9,5))
        if len(self.name) == 0:
            ax.set_title("Equipotential Lines")
        else:
            ax.set_title(f"Equipotential Lines of {self.name}")
        ax.set(xlabel="Horizontal position x (m)", ylabel="Vertical position x (m)")
        ax.grid(visible=True, which='major', axis='both')
        subplots_adjust(hspace=0.5)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == +1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == +1.0], c='red', zorder=1)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == -1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == -1.0], c='blue', zorder=1)
        equipotential_plot = ax.contour(x, y, plotEPotential, levels=equipotential_levels)
        fig.colorbar(equipotential_plot, axbar, label="Electric Potential (V)")
        ax.clabel(equipotential_plot, inline=False, fontsize=10, colors="black")
        show()

    def display_BothEFieldLines_EPotential (self, EFieldDensity = 1.0, max_number_of_potentials = 20, tuple_equipotentials=(), set_zero_potential = False, cutoff_threshold=10):
        # Generate the grid of points to evaluate the electric field and electric potential on the cartesian plane:
        x, y = linspace(self.bound_xmin, self.bound_xmax, self.size_n), linspace(self.bound_ymin, self.bound_ymax,
                                                                                 self.size_m)
        x, y = meshgrid(x, y)

        if (not self.has_computed_EField_x) or (not self.has_computed_EField_y) or (not self.has_computed_EPotential):
            self.AllPotentials = []
            for j in range(self.size_m):
                for i in range(self.size_n):
                    pos_x, pos_y = x[j][i], y[j][i]
                    EField_xcomponent, EField_ycomponent = point_charge.total_EField(pos_x, pos_y)
                    self.EField_x[j][i] = EField_xcomponent
                    self.EField_y[j][i] = EField_ycomponent
                    EPotential_value = point_charge.total_EPotential(pos_x, pos_y)
                    self.EPotential[j][i] = EPotential_value
                    self.AllPotentials.append(EPotential_value)
            self.has_computed_EField_x = True
            self.has_computed_EField_y = True
            self.has_computed_EPotential = True

        # Get the quantile values needed for the potentials
        number_of_quantiles = max_number_of_potentials  # initial number of quantiles (excluding extrema)
        number_of_quantiles += 2  # accounts for the minimum and maximum values (which are excluded)

        # Sort all potential values
        self.AllPotentials.sort()

        # The top-most and bottom-most values will be removed
        # Get quantiles between cutoff_threshold% and (100 - cutoff_threshold)%
        lower_threshold = cutoff_threshold / 100
        upper_threshold = (100 - cutoff_threshold) / 100
        qValues = list(linspace(0, 1, number_of_quantiles))
        qValues = [q for q in qValues if ((q >= lower_threshold) and (q <= upper_threshold))]
        equipotential_levels = list(quantile(self.AllPotentials, qValues))

        # If the zero potential is to be set (True), let the lowest equipotential level be the zero potential.
        plotEPotential = copy(self.EPotential)
        if set_zero_potential:
            zero_potential = equipotential_levels[0]
            for j in range(self.size_m):
                for i in range(self.size_n):
                    plotEPotential[j][i] = plotEPotential[j][i] - zero_potential
            equipotential_levels = [potential - zero_potential for potential in equipotential_levels]

        # If specified, the equipotential levels can then be manually replaced:
        if len(tuple_equipotentials) != 0:
            equipotential_levels = list(tuple_equipotentials).copy()

        # Plot the electric field lines and equipotential lines, with (+) charges in red, and (-) charges in blue
        fig, (ax, axbar) = subplots(ncols=2, gridspec_kw={'width_ratios': [13, 1]}, figsize=(9,5))
        if len(self.name) == 0:
            ax.set_title("Equipotential Lines")
        else:
            ax.set_title(f"Equipotential Lines of {self.name}")
        ax.set(xlabel="Horizontal position x (m)", ylabel="Vertical position x (m)")
        ax.grid(visible=True, which='major', axis='both')
        subplots_adjust(hspace=0.5)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == +1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == +1.0], c='red', zorder=1)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == -1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == -1.0], c='blue', zorder=1)
        equipotential_plot = ax.contour(x, y, plotEPotential, levels=equipotential_levels)
        fig.colorbar(equipotential_plot, axbar, label="Electric Potential (V)")

        ax.streamplot(x, y, self.EField_x, self.EField_y, linewidth=1, density=EFieldDensity, zorder=0, color="black")
        show()

    def display_EmptyPlot_1(self):
        fig, ax = subplots(figsize=(9,5))
        if len(self.name) == 0:
            ax.set_title("Electric Field Lines")
        else:
            ax.set_title(f"Electric Field Lines of {self.name}")
        ax.set(xlabel="Horizontal position x (m)", ylabel="Vertical position x (m)")
        ax.grid(visible=True, which='major', axis='both')
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == +1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == +1.0], c='red', zorder=1)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == -1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == -1.0], c='blue', zorder=1)
        ax.set_xlim([self.bound_xmin, self.bound_xmax])
        ax.set_ylim([self.bound_ymin, self.bound_ymax])
        show()

    def display_EmptyPlot_2(self):
        fig, (ax, axbar) = subplots(ncols=2, gridspec_kw={'width_ratios': [13, 1]}, figsize=(9, 5))
        if len(self.name) == 0:
            ax.set_title("Equipotential Lines")
        else:
            ax.set_title(f"Equipotential Lines of {self.name}")
        ax.set(xlabel="Horizontal position x (m)", ylabel="Vertical position x (m)")
        ax.grid(visible=True, which='major', axis='both')
        subplots_adjust(hspace=0.5)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == +1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == +1.0], c='red', zorder=1)
        ax.scatter([q.pos_x for q in point_charge.set_of_all_charges if q.sign_charge == -1.0],
                   [q.pos_y for q in point_charge.set_of_all_charges if q.sign_charge == -1.0], c='blue', zorder=1)
        ax.set_xlim([self.bound_xmin, self.bound_xmax])
        ax.set_ylim([self.bound_ymin, self.bound_ymax])
        show()

    def allow_recomputation(self):
        self.has_computed_EField_x = False
        self.has_computed_EField_y = False
        self.has_computed_EPotential = False


# ----------------------------------------
# Calculate the force experienced by Charge II (Practice Problem for Coulomb's Law)
"""
qI = 6.0*10**(-6) # Coulombs
qII = -4.0*10**(-6) #Coulombs
qIII = -8.0*10**(-6) #Coulombs
L = 2.0 # Meters

chargeI = point_charge(qI, 0.0, 0.0)
chargeII = point_charge(qII, L, 0.0)
chargeIII = point_charge(qIII, 0.0, L)

Force_on_II = chargeII.net_electrostatic_force_2()
print(Force_on_II)
"""

# ----------------------------------------
# CASE #1 - Two Circles


# Declare first the electric charges
"""
point_charge.clear()
e = point_charge.const_electronic_charge
conductorCharge = 1.65*e*(10**10)

chargedDisk(charge=conductorCharge,
            center_x = 8.0,
            center_y= 0.0,
            ring_diameter= 2.3,
            tuple_number_of_points=(6, 9, 12))
chargedDisk(charge=-conductorCharge,
            center_x = -8.0,
            center_y= 0.0,
            ring_diameter= 2.3,
            tuple_number_of_points=(6,9, 12))

# Plot the electric field lines and equipotential lines
EFieldDisplay = electric_field_display(bound_xmin = -10.0,
                                       bound_ymin = -7.0,
                                       bound_xmax = 10.0,
                                       bound_ymax = 7.0,
                                       resolution = 15,
                                       name="Two Charged Circular Conductors")
EFieldDisplay.display_BothEFieldLines_EPotential(EFieldDensity=0.5,
                                                 max_number_of_potentials=9,
                                                 set_zero_potential=True,
                                                 tuple_equipotentials=(0.00, 2.73, 4.40, 6.21, 8.0, 9.6, 12.05))
EFieldDisplay.display_EFieldLines(EFieldDensity=0.5)
EFieldDisplay.display_EmptyPlot_1()
EFieldDisplay.display_EPotential(set_zero_potential=True,
                                 max_number_of_potentials=9,
                                 tuple_equipotentials=(0.00, 2.73, 4.40, 6.21, 8.0, 9.6, 12.05))
EFieldDisplay.display_EmptyPlot_2()
"""


# ----------------------------------------
# CASE #2 - Two Bars
# Declare first the electric charges

'''
point_charge.clear()
e = point_charge.const_electronic_charge
conductorCharge = 4.70*e*(10**10)

chargedBar(-conductorCharge, -7.5, 5, 7.5, 5, 20, 4, 7.5)
chargedBar(conductorCharge, -7.5, -5, 7.5, -5, 20, 4, 7.5)

# Plot the electric field lines and equipotential lines
EFieldDisplay = electric_field_display(bound_xmin = -10.0,
                                       bound_ymin = -7.0,
                                       bound_xmax = 10.0,
                                       bound_ymax = 7.0,
                                       resolution = 15,
                                       name="Two Charged Bar-Shaped Conductors")
EFieldDisplay.display_BothEFieldLines_EPotential(EFieldDensity=0.5,
                                                 max_number_of_potentials=9,
                                                 set_zero_potential=True,
                                                 tuple_equipotentials=(0.00, 2.50, 4.86, 5.95, 7.00, 9.40, 12.00),
                                                 cutoff_threshold=26)
EFieldDisplay.display_EFieldLines(EFieldDensity=0.5)
EFieldDisplay.display_EmptyPlot_1()
EFieldDisplay.display_EPotential(set_zero_potential=True,
                                 max_number_of_potentials=9,
                                 tuple_equipotentials=(0.00, 2.50, 4.86, 5.95, 7.00, 9.40, 12.0),
                                 cutoff_threshold=26)
EFieldDisplay.display_EmptyPlot_2()
'''

# ----------------------------------------
# CASE #3 - Bar and Circle

'''
# Declare first the electric charges
point_charge.clear()
e = point_charge.const_electronic_charge
conductorCharge = 6.04*e*(10**10)

chargedBar(charge=-conductorCharge,
           start_x=-7.5,
           start_y=5,
           end_x=7.5,
           end_y=5,
           number_of_column_points=20,
           number_of_row_points=4,
           aspect_ratio=7.5)
chargedDisk(charge=conductorCharge,
            center_x = 0.0,
            center_y= -5.5,
            ring_diameter= 2.3,
            tuple_number_of_points=(6,9, 12))

# Plot the electric field lines and equipotential lines
EFieldDisplay = electric_field_display(bound_xmin = -10.0,
                                       bound_ymin = -7.0,
                                       bound_xmax = 10.0,
                                       bound_ymax = 7.0,
                                       resolution = 15,
                                       name="A Charged Circular Conductor and A Charged Bar Conductor")
EFieldDisplay.display_BothEFieldLines_EPotential(EFieldDensity=0.5,
                                                 max_number_of_potentials=9,
                                                 set_zero_potential=True,
                                                 cutoff_threshold=22,
                                                 tuple_equipotentials=(0.00, 2.00, 4.00, 5.30, 7.02, 8.70, 12.00))
EFieldDisplay.display_EFieldLines(EFieldDensity=0.5)
EFieldDisplay.display_EmptyPlot_1()
EFieldDisplay.display_EPotential(set_zero_potential=True,
                                 max_number_of_potentials=9,
                                 cutoff_threshold=22,
                                 tuple_equipotentials=(0.00, 2.00, 4.00, 5.30, 7.02, 8.70, 12.00))
EFieldDisplay.display_EmptyPlot_2()
'''


# ----------------------------------------
# SPECIAL CASE: Intersecting Equipotential Lines

# Declare first the electric charges
point_charge.clear()
e = point_charge.const_electronic_charge
conductorCharge = 3*e*(10**10)

chargedBar(charge=conductorCharge,
           start_x=-7.5,
           start_y=5,
           end_x=7.5,
           end_y=5,
           number_of_column_points=20,
           number_of_row_points=1,
           aspect_ratio=7.5)

point_charge(charge=conductorCharge,
             position_x = 0.0,
             position_y = -5.5)

# Plot the electric field lines and equipotential lines
EFieldDisplay = electric_field_display(bound_xmin = -10.0,
                                       bound_ymin = -7.0,
                                       bound_xmax = 10.0,
                                       bound_ymax = 7.0,
                                       resolution = 15,
                                       name="Setup with Intersecting Equipotential Lines")
print(point_charge.total_EPotential(0.0, 0.70))
EFieldDisplay.display_BothEFieldLines_EPotential(EFieldDensity=0.5,
                                                 max_number_of_potentials=15,
                                                 set_zero_potential=False,
                                                 cutoff_threshold=10,
                                                 tuple_equipotentials=(9, 10, 11, 12, 13, 14, 14.458, 15, 16, 17, 18, 19, 20))
EFieldDisplay.display_EFieldLines(EFieldDensity=0.5)
EFieldDisplay.display_EmptyPlot_1()
EFieldDisplay.display_EPotential(set_zero_potential=False,
                                 max_number_of_potentials=15,
                                 cutoff_threshold=10,
                                 tuple_equipotentials=(9, 10, 11, 12, 13, 14, 14.458, 15, 16, 17, 18, 19, 20))
EFieldDisplay.display_EmptyPlot_2()
